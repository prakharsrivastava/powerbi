import org.springframework.http.HttpStatus;
import org.springframework.web.reactive.function.client.WebClient;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import org.junit.jupiter.api.Assertions; // JUnit 5 assertions

public class Main {

    private WebClient client;

    public Main() {
        // Initialize WebClient
        client = WebClient.create("http://example.com");
    }

    public void method1() {
        // Call the web client and block until the response is received
        CompletableFuture<Pair<HttpStatus, Optional<String>>> futureResponse = CompletableFuture.supplyAsync(() -> 
            callWebClient(() -> client.method1().block())
        );

        // Wait for the response and then assert that the response status is OK
        Pair<HttpStatus, Optional<String>> response = futureResponse.join();  // This blocks until the CompletableFuture completes

        // Assert that the response status is OK
        Assertions.assertEquals(HttpStatus.OK, response.getKey(), "Expected HTTP status OK, but got: " + response.getKey());
    }

    public Pair<HttpStatus, Optional<String>> callWebClient(Supplier<String> supplier) {
        try {
            // Call the supplier method (blocking WebClient call)
            String responseBody = supplier.get();
            HttpStatus status = HttpStatus.OK; // Set the status based on your logic
            return new Pair<>(status, Optional.ofNullable(responseBody));
        } catch (Exception e) {
            e.printStackTrace();
            return new Pair<>(HttpStatus.INTERNAL_SERVER_ERROR, Optional.empty());
        }
    }

    public static void main(String[] args) {
        Main main = new Main();
        main.method1();
    }
}

// A simple Pair class if not using Java
